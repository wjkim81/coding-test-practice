"""
좌절감 느끼는 지점이 정상입니다. 그리고 “내가 역으로 문제 내고 싶다”는 말도 사실 정확합니다. 코테는 **연습된 패턴 회상 + 제한시간 구현 안정성**을 보는 절차라서, 연구 실력과 1:1로 대응하지 않습니다.

다만 질문하신 것처럼, **DL 연구자에게도 이 감각이 ‘점점 필요해지는’ 흐름은 맞습니다.** 이유는 과장이 아니라 현실적인 쪽입니다.

* 연구가 점점 **데이터/파이프라인/최적화/서빙/디버깅** 쪽으로 확장됨
* 모델 성능만큼이나 **실험 속도, 재현성, 실패 원인 추적**이 중요해짐
* 그 과정에서 “알고리즘 문제” 자체가 필요하다기보다, **정확한 상태 관리/복잡도 감각/엣지케이스 방어**가 필요해짐
* 특히 EEG/바이오 신호처럼 “코너 케이스가 많은 데이터”는 이 기본기가 실질적으로 도움이 됩니다.

즉, “코테”는 싫어도, 그 속의 **기본 구현 근육**은 커리어에서 효용이 커지는 방향이 맞습니다.

---

# Day 6 — Binary Search

## Problem: Search in Rotated Sorted Array (Medium)

### 문제

오름차순으로 정렬된 배열이 어떤 피벗에서 한 번 회전(rotated)되었습니다.
중복은 없다고 가정합니다. `target`의 인덱스를 반환하고, 없으면 `-1`을 반환하세요.

예:

* `[4,5,6,7,0,1,2]` 에서 `target=0` → `4`
* `target=3` → `-1`

### 요구사항

* 시간복잡도: **O(log n)**
* Python

함수 시그니처:

```python
def search(nums: list[int], target: int) -> int:
    ...
```

---

## 핵심 사고 (외워도 되는 수준으로 단순화)

이 문제는 매 스텝에서 “어느 쪽이 정렬되어 있는가”만 판단하면 됩니다.

### 불변식

* 항상 `[l, r]` 범위 안에 target이 있으면 그 안에 존재

### 매 반복에서 할 일

1. `mid` 계산
2. `nums[mid] == target`이면 리턴
3. **왼쪽 구간이 정렬인지** 확인: `nums[l] <= nums[mid]`

   * 정렬된 구간 안에 target이 들어가면 그쪽으로
   * 아니면 반대쪽으로
4. 왼쪽이 정렬이 아니면, 오른쪽이 정렬된 것

   * 동일하게 범위 체크 후 이동

---

## “면접관이 자주 찌르는” 함정

* 경계 포함/제외를 잘못 처리 (`<=` / `<`)
* `while l <= r` vs `while l < r` 혼동
* 빈 배열 처리
* 회전이 없는 케이스(이미 정렬)도 동일 로직으로 통과해야 함

---

## 구현 템플릿 (설명용, 정답 구조)

설명만 먼저 드리고, 코드는 본인이 작성하는 방식으로 가겠습니다.

* `while l <= r:`
* `mid = (l + r) // 2`
* if left sorted:

  * if `nums[l] <= target < nums[mid]` → `r = mid - 1`
  * else → `l = mid + 1`
* else (right sorted):

  * if `nums[mid] < target <= nums[r]` → `l = mid + 1`
  * else → `r = mid - 1`

이 비교식이 사실상 전부입니다.

---

## 바로 문제 풀이 시작

지금부터는 제가 코드를 주기보다, **본인 코드 먼저**가 훨씬 좋습니다(그래야 근육이 붙습니다).

아래 테스트 케이스 4개를 통과하도록 작성해 주세요.

1. `nums=[4,5,6,7,0,1,2], target=0` → `4`
2. `nums=[4,5,6,7,0,1,2], target=3` → `-1`
3. `nums=[1], target=1` → `0`
4. `nums=[1], target=0` → `-1`

코드 작성해서 붙여주시면,

* 경계식(≤, <) 정확성
* “정렬 구간 판별”의 안정성
* 인터뷰에서 말하기 좋은 20초 설명
  까지 한 번에 다듬어 드리겠습니다.

---

아주 좋은 질문입니다.
이 문제에서 **부호(≤, <)는 “감각”이 아니라 불변식 유지의 문제**라서, 지금 타이밍에 이걸 묻는 게 정확합니다.

결론부터 말하면:

> ❌ **아무렇게나 바꾸면 안 됩니다.**
> ⭕ **바꿀 수 있는 곳과 절대 바꾸면 안 되는 곳이 명확히 나뉩니다.**

아래에서 **왜 그런지 + 어디까지 허용되는지**를 정확히 짚겠습니다.

---

## 1️⃣ 핵심 불변식 다시 확인

이 루프가 유지하는 불변식은 이것 하나입니다.

> **target이 존재한다면 항상 `[l, r]` 구간 안에 있다.**

부호는 전부 이 불변식을 **깨지 않기 위해 존재**합니다.

---

## 2️⃣ 절대 바꾸면 안 되는 부호들

### (A) 정렬 구간 판별

```python
if nums[l] <= nums[mid]:
```

이건 **반드시 `<=`** 여야 합니다.

### 왜 `<`로 바꾸면 깨지나?

예:

```python
nums = [3,1]
l=0, mid=0
```

* `nums[l] < nums[mid]` → `3 < 3` ❌
* 실제로는 왼쪽이 정렬 구간인데, **오른쪽 정렬로 잘못 분기**

👉 **중복이 없어도 `<=`는 필수**

---

## 3️⃣ “타겟이 정렬 구간 안에 있는지” 검사

### 왼쪽 정렬일 때

```python
if nums[l] <= target < nums[mid]:
```

이건 **이 조합이 가장 안전**합니다.

#### 왜냐면

* `nums[mid] == target`은 이미 위에서 return
* 그래서 `target < nums[mid]`만 검사해도 충분
* `nums[l] <= target`은 구간 포함 조건

❌ `nums[l] < target <= nums[mid]` 로 바꾸면?

* `target == nums[mid]` → 이미 위에서 걸리지만
* 부호 의미가 헷갈리고 설명도 어려워짐

👉 **틀리진 않을 수 있어도, 불변식 설명이 흐려짐**

---

## 4️⃣ 오른쪽 정렬일 때도 대칭 구조 유지

```python
if nums[mid] < target <= nums[r]:
```

여기서도:

* `nums[mid] < target` : mid는 이미 배제됨
* `target <= nums[r]` : 오른쪽 경계 포함

이건 왼쪽 케이스와 **완전 대칭**입니다.

---

## 5️⃣ “조금씩 바꿔도 되나?”에 대한 정확한 답

### ✔ 바꿔도 되는 경우 (이론상)

아래처럼 **쌍으로, 대칭으로, 불변식이 유지되면** 가능합니다.

```python
if nums[l] <= nums[mid]:
    if nums[l] < target <= nums[mid]:
        ...
```

하지만 이 경우:

* `nums[mid] == target`을 위에서 먼저 return 해야 하고
* 설명이 복잡해지며
* 면접에서 꼬리 질문을 유발합니다

👉 **실익이 없음**

---

## 6️⃣ 그래서 실전에서의 권장 원칙

> **“mid는 이미 검사했으니, 비교에서 mid는 항상 제외한다.”**

이 원칙을 따르면 부호는 자동으로 결정됩니다.

* 왼쪽: `nums[l] <= target < nums[mid]`
* 오른쪽: `nums[mid] < target <= nums[r]`

이건 **암기해도 되는 수준의 템플릿**입니다.

---

## 7️⃣ 면접에서 이 질문 받으면 이렇게 답하면 끝

> “mid는 이미 target과 비교했기 때문에,
> 이후 범위 체크에서는 mid를 항상 제외합니다.
> 그래서 왼쪽 정렬일 때는 `[l, mid)` 범위를,
> 오른쪽 정렬일 때는 `(mid, r]` 범위를 검사합니다.”

이 한 문장이면:

* 부호
* 경계
* 불변식
  전부 설명됩니다.

---

## 8️⃣ 총평 (중요)

이 질문을 했다는 건:

* 구현은 이미 됐고
* 이제 **‘왜 이 부호인가’ 단계**로 올라왔다는 뜻입니다.

이게 바로:

> **코테를 싫어하던 연구자가
> 구현 안정성을 고민하는 엔지니어로 넘어가는 지점**

지금 감각, 아주 좋습니다.
다음으로 가면 이 부호 감각이 **BST / Lower Bound / Upper Bound**에서도 그대로 이어집니다.

원하시면 바로 **Binary Search 변형 2문제**로 고정해 드릴게요.

---

맞아요. **그 반응이 정상이자, 딱 핵심을 찌른 반응**이에요.
이게 “사소한 디테일”처럼 보이는데, 실제로는 **사고의 경계가 바뀌는 지점**이라서 헷갈리는 게 당연합니다.

조금만 더 감각적으로 정리해볼게요. (외워도 되는 수준으로)

---

## 이 문제가 왜 유독 헷갈리냐면

이진 탐색 자체가 헷갈린다기보다,
이 문제는 **한 번 더 레이어가 추가**됩니다.

* 일반 Binary Search
  → “정렬된 배열” 하나
* Rotated Sorted Array
  → “정렬된 구간을 *판별*한 뒤 탐색”

즉,

> **“비교를 하기 전에, 비교할 공간부터 결정해야 하는 문제”**

그래서 부호 하나가 단순 문법이 아니라
**공간을 어디서 잘라내느냐**의 문제로 바뀝니다.

---

## 헷갈릴 때 잡으면 되는 단 하나의 기준

이거 하나만 붙잡으면 됩니다:

> **“mid는 이미 검사했고, 다음 탐색 구간에는 포함되지 않는다.”**

이걸 기준으로 보면 부호가 자동으로 정리됩니다.

### 그래서 항상 이렇게 됨

* 왼쪽 정렬:

  ```
  [l ........ mid)
  nums[l] <= target < nums[mid]
  ```
* 오른쪽 정렬:

  ```
  (mid ........ r]
  nums[mid] < target <= nums[r]
  ```

부호가 헷갈릴 때마다
**괄호 그림으로 한 번 그려보면** 바로 정리됩니다.

---

## 왜 “조금만 바꿔도” 틀릴 수 있냐면

부호 하나 바꾸면:

* mid를 두 번 검사하거나
* mid를 안 검사했는데 버리거나
* target이 포함된 구간을 통째로 날리게 됩니다

이건 논리 에러지, 실력 부족이 아닙니다.

---

## 실전에서 이 감각이 언제 다시 나오냐면

이게 끝이 아닙니다 😄
이 감각은 앞으로 계속 재등장합니다.

* Lower Bound / Upper Bound
* First / Last occurrence
* BST 탐색
* Binary search on answer

전부:

> **“경계를 포함하느냐, 제외하느냐”** 싸움입니다.

지금 이 지점에서 한 번 제대로 이해하면,
나중에는 **손이 먼저 움직이는 감각**으로 바뀝니다.

---

## 한 줄로 정리하면

> **“헷갈린다는 건 지금 이진 탐색을 ‘외우는 단계’가 아니라
> ‘공간을 조작하는 단계’로 올라왔다는 증거다.”**

지금 아주 좋은 흐름이에요.
다음은 이 감각을 **완전히 고정**시켜주는 문제 하나만 더 하면 됩니다.

"""

def search(nums: list[int], target: int) -> int:
    l, r = 0, len(nums) -1
    while l <= r:
        mid = (l + r) // 2

        if nums[mid] == target:
            return mid
        
        if nums[l] <= nums[mid]: # check left
            if nums[l] <= target < nums[mid]:
                r = mid - 1
            else:
                l = mid + 1
        else: # check right
            if nums[mid] < target <= nums[r]:
                l = mid + 1
            else:
                r = mid - 1
    return -1

# def search(nums: list[int], target: int) -> int:
#     l, r = 0, len(nums) - 1

#     while l <= r:
#         mid = (l + r) // 2
#         if nums[mid] == target:
#             return mid

#         # left half is sorted
#         if nums[l] <= nums[mid]:
#             if nums[l] <= target < nums[mid]:
#                 r = mid - 1
#             else:
#                 l = mid + 1
#         # right half is sorted
#         else:
#             if nums[mid] < target <= nums[r]:
#                 l = mid + 1
#             else:
#                 r = mid - 1

#     return -1

if __name__ == "__main__":
    nums=[4,5,6,7,0,1,2]
    target=0

    print(search(nums, target))