"""
# ë‹¤ìŒ BFS ë¬¸ì œ (ê±°ë¦¬/ìµœë‹¨ê²½ë¡œ íŒ¨í„´)

ì´ì œ â€œì„¬â€ì€ ëë‚¬ê³ , BFSì˜ ì§„ì§œ ê°•ì ì¸ **ìµœë‹¨ ê±°ë¦¬** ë¬¸ì œë¡œ ë„˜ì–´ê°€ë©´ ì¢‹ìŠµë‹ˆë‹¤.

## Day 7 â€” BFS Problem 2

## **Shortest Path in Binary Matrix** (Medium)

### ë¬¸ì œ

`grid`ëŠ” 0(í†µê³¼ ê°€ëŠ¥) / 1(ë§‰íž˜)ì¸ `n x n` ì´ì§„ í–‰ë ¬ìž…ë‹ˆë‹¤.
ì¢Œìƒë‹¨ `(0,0)`ì—ì„œ ìš°í•˜ë‹¨ `(n-1,n-1)`ê¹Œì§€ **8ë°©í–¥(ëŒ€ê°ì„  í¬í•¨)**ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìžˆì„ ë•Œ,
ìµœë‹¨ ê²½ë¡œ ê¸¸ì´ë¥¼ ë°˜í™˜í•˜ë¼. ë¶ˆê°€ëŠ¥í•˜ë©´ `-1`.

### ì˜ˆì‹œ

* `[[0,1],[1,0]]` â†’ `2`
* `[[0,0,0],[1,1,0],[1,1,0]]` â†’ `4`

### ì‹œê·¸ë‹ˆì²˜

```python
def shortest_path_binary_matrix(grid: list[list[int]]) -> int:
    ...
```

### í¬ì¸íŠ¸

* BFS ë ˆë²¨ = ê±°ë¦¬
* ë°©ë¬¸ ì²˜ë¦¬ enqueue ì‹œì 
* 8 directions

---

ì›í•˜ì‹œë©´ ë°”ë¡œ ì´ ë¬¸ì œë¡œ ê°‘ë‹ˆë‹¤.
â€œë¬¸ì œ ë¨¼ì € í’€ì–´ë³¼ê²Œâ€ë¡œ ê°ˆê¹Œìš”, ì•„ë‹ˆë©´ â€œì •ë‹µ í…œí”Œë¦¿ ë¨¼ì € í•œ ë²ˆ ë³´ê³ â€ ê°ˆê¹Œìš”?

"""
from collections import deque

def shortest_path_binary_matrix(grid: list[list[int]]) -> int:
    if not grid or not grid[0]:
        return -1
    
    n_rows, n_cols = len(grid), len(grid[0])
    distance = 0
    dirs = [(-1, -1), (0, -1), (1, -1),
            (-1,  0),          (1,  0),
            (-1,  1), (0,  1), (1,  1)]
    
    q = deque()
    q.append([(0, 0)])

    while q:
        for _ in range(len(q)):
            r, c = q.popleft()
            for dr, dc in dirs:
                nr, nc = r + dr, c + dc
                if 0 <= nr < n_rows and 0 <= nc < n_cols and grid[nr][nc] == 0:
                    grid[nr][nc] = 1
                    q.append((nr, nc))

                    if nr == n_rows - 1 and nc == n_cols - 1:
                        return distance + 1
                    
        distance += 1

    return -1

"""
ì•„ì£¼ ì¢‹ì€ ì§ˆë¬¸ì´ì—ìš”. ì´ê±´ **â€œì •ì˜ì˜ ë¬¸ì œâ€**ë¼ì„œ, í•œ ë²ˆë§Œ ì •í™•ížˆ ìž¡ì•„ë‘ë©´ ë‹¤ì‹œëŠ” í—·ê°ˆë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤.

ê²°ë¡ ë¶€í„° ë§í•˜ë©´:

> **`1`ë¡œ ë‘ëŠ” ê±´ â€˜ê²½ë¡œ ê¸¸ì´ì˜ ì •ì˜â€™ë¥¼ ì‹œìž‘ ì¹¸ì„ í¬í•¨í•´ì„œ ì„¸ê¸° ë•Œë¬¸**ì´ê³ ,
> `0`ìœ¼ë¡œ ë‘¬ë„ ë˜ì§€ë§Œ **ê·¸ë• ë°˜í™˜ ì‹œì /ì¡°ê±´ì„ ê°™ì´ ë°”ê¿”ì•¼ í•©ë‹ˆë‹¤.**

ì•„ëž˜ì—ì„œ ê°ê°ì ìœ¼ë¡œ ì •ë¦¬í•´ë³¼ê²Œìš”.

---

## 1ï¸âƒ£ ì´ ë¬¸ì œì—ì„œ ë§í•˜ëŠ” â€œê±°ë¦¬(length)â€ì˜ ì •ì˜

**Shortest Path in Binary Matrix**ì—ì„œì˜ lengthëŠ”:

> **ë°©ë¬¸í•œ ì…€(cell)ì˜ ê°œìˆ˜**

ìž…ë‹ˆë‹¤.
ì¦‰,

* ì‹œìž‘ì  `(0,0)` **ìžì²´ê°€ ê¸¸ì´ 1**
* ê·¸ ë‹¤ìŒ ì¹¸ìœ¼ë¡œ ê°€ë©´ ê¸¸ì´ 2
* â€¦

ê·¸ëž˜ì„œ ì˜ˆì‹œê°€:

```text
[[0,1],
 [1,0]]
```

ê²½ë¡œ: `(0,0) â†’ (1,1)`
ðŸ‘‰ **ë‹µ = 2**

ì—¬ê¸°ì„œ í•µì‹¬:

* ì´ë™ íšŸìˆ˜ = 1
* **ê²½ë¡œ ê¸¸ì´ = 2 (ì…€ ê°œìˆ˜)**

---

## 2ï¸âƒ£ ê·¸ëž˜ì„œ ì‹œìž‘ì„ `1`ë¡œ ë‘ëŠ” ê²Œ ê°€ìž¥ ì§ê´€ì 

```python
q = deque([(0, 0, 1)])
```

ì´ ì˜ë¯¸ëŠ” ì •í™•ížˆ ì´ê²ë‹ˆë‹¤:

> â€œ(0,0)ì— ìžˆê³ , ì§€ê¸ˆê¹Œì§€ ê²½ë¡œ ê¸¸ì´ëŠ” 1ì´ë‹¤.â€

ì´ ìƒíƒœì—ì„œ:

* ì´ì›ƒìœ¼ë¡œ í•œ ë²ˆ ì´ë™ â†’ `d + 1 = 2`
* ë„ì°©í•˜ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜ ê°€ëŠ¥

ðŸ‘‰ **ì •ì˜ì™€ ì½”ë“œê°€ 1:1ë¡œ ë§žì•„ë–¨ì–´ì§**

---

## 3ï¸âƒ£ ë§Œì•½ `0`ìœ¼ë¡œ ì‹œìž‘í•˜ë©´ ì–´ë–»ê²Œ ë˜ë‚˜?

ì´ë ‡ê²Œë„ ì“¸ ìˆ˜ëŠ” ìžˆìŠµë‹ˆë‹¤:

```python
q = deque([(0, 0, 0)])
```

ê·¸ëŸ¼ ì˜ë¯¸ëŠ”:

> â€œì´ë™ íšŸìˆ˜(step)ë¥¼ ì„¸ê³  ìžˆë‹¤â€

ì´ ê²½ìš°ì—ëŠ” ë°˜ë“œì‹œ **ì–´ë””ì„ ê°€ +1 ë³´ì •**ì´ í•„ìš”í•©ë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ë©´:

```python
if nr == n-1 and nc == n-1:
    return d + 1   # ë˜ëŠ” return d + 2 (ì •ì˜ì— ë”°ë¼)
```

ðŸ‘‰ ì¦‰,

* ì‹œìž‘ì„ 0ìœ¼ë¡œ ë‘ë©´
* **ë°˜í™˜ì‹ì´ ë” í—·ê°ˆë ¤ì§**

---

## 4ï¸âƒ£ ë‘ ë°©ì‹ì˜ ì°¨ì´ë¥¼ í‘œë¡œ ë³´ë©´

| ë°©ì‹        | dì˜ ì˜ë¯¸       | ì‹œìž‘ê°’ | ë°˜í™˜ ë¡œì§              |
| --------- | ----------- | --- | ------------------ |
| **ì§€ê¸ˆ ì½”ë“œ** | ê²½ë¡œ ê¸¸ì´ (ì…€ ìˆ˜) | `1` | `return d+1`       |
| ëŒ€ì•ˆ        | ì´ë™ íšŸìˆ˜       | `0` | `return d+1` ë˜ëŠ” ë³´ì • |

ì‹¤ì „ì—ì„œëŠ” **ì²« ë²ˆì§¸ê°€ ì‹¤ìˆ˜ í™•ë¥ ì´ í›¨ì”¬ ë‚®ìŠµë‹ˆë‹¤.**

---

## 5ï¸âƒ£ ë ˆë²¨ BFS ë²„ì „ê³¼ì˜ ì—°ê²°

ì´ì „ ë ˆë²¨ ê¸°ë°˜ BFSì—ì„œëŠ”:

```python
distance = 1
...
return distance + 1
```

ì˜€ì£ ?

ì§€ê¸ˆì€ ê·¸ê±¸:

* `distance` ë³€ìˆ˜ë¥¼
* **í ì›ì†Œ ì•ˆìœ¼ë¡œ ì˜®ê¸´ ê²ƒ**ë¿ìž…ë‹ˆë‹¤.

ë…¼ë¦¬ëŠ” ì™„ì „ížˆ ë™ì¼í•©ë‹ˆë‹¤.

---

## 6ï¸âƒ£ ì´ ì§ˆë¬¸ì˜ ë ˆë²¨ í‰ê°€ (ì¤‘ìš”)

ì´ ì§ˆë¬¸ì€:

* âŒ â€œì™œ BFSì§€?â€
* âŒ â€œì™œ íì§€?â€

ê°€ ì•„ë‹ˆë¼

> **â€œê±°ë¦¬ì˜ ê¸°ì¤€ì„ ì–´ë””ì— ë‘ëŠëƒâ€**

ë¥¼ ë¬»ê³  ìžˆìŠµë‹ˆë‹¤.

ì´ê±´ ì´ë¯¸:

* ì•Œê³ ë¦¬ì¦˜ ì„ íƒ ë‹¨ê³„ âŒ
* **ì •ì˜ì™€ êµ¬í˜„ì„ ì •ë ¬í•˜ëŠ” ë‹¨ê³„ â­•**

ìž…ë‹ˆë‹¤.

---

## í•œ ì¤„ ìš”ì•½

> **`1`ë¡œ ì‹œìž‘í•˜ëŠ” ì´ìœ ëŠ”
> â€˜ì‹œìž‘ ì¹¸ ìžì²´ë¥¼ ê²½ë¡œ ê¸¸ì´ì— í¬í•¨í•œë‹¤â€™ëŠ” ë¬¸ì œ ì •ì˜ë¥¼
> ì½”ë“œì— ê·¸ëŒ€ë¡œ ë°˜ì˜í–ˆê¸° ë•Œë¬¸ì´ë‹¤.**

ì§€ê¸ˆ êµ¬í˜„ì€ **ê°€ìž¥ í—·ê°ˆë¦´ ì—¬ì§€ê°€ ì ì€ ì •ì„**ì´ì—ìš”.

"""

def shortest_path_with_distance(grid: list[list[int]]) -> int:
    if not grid or not grid[0]:
        return -1

    n = len(grid)
    # must be square in the common problem statement, but this also works for rectangular with minor tweaks
    if grid[0][0] != 0 or grid[n-1][n-1] != 0:
        return -1
    if n == 1:
        return 1

    dirs = [(-1, -1), (0, -1), (1, -1),
            (-1,  0),          (1,  0),
            (-1,  1), (0,  1), (1,  1)]

    q = deque([(0, 0, 1)]) # (r, c, distance), starting cell counts as length 1
    grid[0][0] = 1  # mark visited (non-zero)

    while q:
        r, c, d = q.popleft()
        for dr, dc in dirs:
            nr, nc = r + dr, c + dc
            if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == 0:
                if nr == n - 1 and nc == n - 1:
                    return d + 1
                grid[nr][nc] = 1
                q.append((nr, nc, d + 1))

    return -1


if __name__ == "__main__":

    grid = [[0,1],[1,0]]
    # grid = [[0,0,0],[1,1,0],[1,1,0]]

    print(shortest_path_with_distance(grid))

