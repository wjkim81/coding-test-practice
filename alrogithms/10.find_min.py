"""
좋습니다. **Day 6 마무리: Find Minimum in Rotated Sorted Array (Medium)** 갑니다.
방금 했던 rotated-search와 같은 계열인데, 이번엔 `target`이 없고 **“피벗(최솟값)”**을 찾는 문제라 조건이 더 단순합니다.

---

# Day 6 — Problem 2

## Find Minimum in Rotated Sorted Array (Medium)

### 문제

오름차순 정렬된 배열이 한 번 회전(rotated)되었습니다.
중복은 없다고 가정합니다. **최솟값을 반환**하세요.

예:

* `[3,4,5,1,2]` → `1`
* `[4,5,6,7,0,1,2]` → `0`
* `[11,13,15,17]` → `11` (회전 없음)

### 요구사항

* 시간복잡도: **O(log n)**
* Python

시그니처:

```python
def find_min(nums: list[int]) -> int:
    ...
```

---

## 핵심 인사이트 (외워도 되는 수준)

이 문제는 매 단계에서 `mid`가 **왼쪽 정렬 덩어리인지 / 오른쪽(최솟값 포함) 덩어리인지**만 보면 됩니다.

가장 안전한 판별은:

> `nums[mid] > nums[r]` 이면
> 최솟값은 **mid 오른쪽**에 있다 → `l = mid + 1`

> 그렇지 않으면
> 최솟값은 **mid 포함 왼쪽**에 있다 → `r = mid`

여기서 포인트:

* `r = mid - 1`가 아니라 **`r = mid`** 입니다.
  (mid 자체가 최솟값일 수 있으니까)

---

## 코테 함정 체크

* 회전이 없는 경우도 동일 로직으로 처리돼야 함
* 종료 조건: 보통 `while l < r`
* 마지막에 `nums[l]` 반환

---

## 테스트 케이스 4개 (이거로 검증)

1. `[3,4,5,1,2]` → 1
2. `[4,5,6,7,0,1,2]` → 0
3. `[11,13,15,17]` → 11
4. `[2,1]` → 1

---

## 요청

이번에도 **본인 코드 먼저** 작성해서 붙여주세요.
제가 경계(`l<r`, `r=mid`)와 예외 케이스까지 바로 리뷰해 드리겠습니다.

---

아주 좋은 질문입니다.
이건 **이진 탐색에서 가장 자주 헷갈리고, 동시에 가장 중요한 기준**이라서 한 번 정확히 정리해두면 이후 문제가 훨씬 편해집니다.

결론부터 명확히 말하면:

> **`l < r` vs `l <= r`의 차이는
> “이 루프가 값을 *확정*하는 과정인가,
> 아니면 값을 *검사*하는 과정인가”의 차이입니다.**

아래에서 그 기준을 차분히 정리해볼게요.

---

## 1️⃣ 두 형태의 본질적 차이

### `while l <= r:`

👉 **“mid를 실제 후보로 검사한다”**는 의미

* 루프 안에서:

  * `nums[mid] == target` 같은 **직접 비교**
  * 성공하면 **즉시 return**
* `mid`는 매번 “검사 대상”
* 탐색 대상이 **하나의 값(target)**

👉 **Search 문제**에 적합
(예: Binary Search, Rotated Search)

---

### `while l < r:`

👉 **“구간을 점점 좁혀서 답이 하나로 수렴하게 한다”**

* 루프 안에서:

  * 값을 확정하지 않음
  * **어느 쪽에 답이 있는지만 제거**
* 종료 시점:

  * `l == r` → 그 인덱스가 **정답**
* `mid`는 “판별용 분기점”일 뿐

👉 **Minimum / Boundary / Lower Bound 문제**에 적합

---

## 2️⃣ 지금 문제(Find Minimum)에 왜 `l < r`가 맞는가

이 문제의 성격을 한 문장으로 말하면:

> **“값을 찾는 게 아니라, 정답이 있는 구간을 줄이는 문제”**

여기서는:

* `nums[mid] == 정답`인지 **검사하지 않음**
* 오직:

  * “최솟값이 왼쪽에 있는가?”
  * “오른쪽에 있는가?”
    만 판단합니다.

그래서:

* `mid`를 직접 return할 일이 없음
* `mid`는 제거되거나, 포함되거나 둘 중 하나

👉 이런 경우는 **`l < r`가 자연스러운 종료 조건**입니다.

---

## 3️⃣ 왜 `r = mid`이고, `r = mid - 1`이 아닌가

이건 `l < r`와 강하게 연결됩니다.

```python
if nums[mid] > nums[r]:
    l = mid + 1
else:
    r = mid
```

여기서 중요한 사실:

* `nums[mid] <= nums[r]` 인 경우
  → **mid 자체가 최솟값일 수도 있음**

그래서:

* mid를 버리면 ❌
* mid를 포함해야 ⭕

→ `r = mid` 가 되는 것

그리고 이게 가능하려면:

* `mid`를 포함한 상태에서
* 구간이 계속 줄어들어야 함
  → **`l < r` 구조가 필요**

---

## 4️⃣ 그럼 `l <= r`로도 쓸 수 있나?

이론적으로는 가능합니다.
하지만 그 경우에는:

* 종료 조건이 복잡해지고
* mid == l == r 인 상황을 직접 처리해야 하고
* 불필요한 분기/return이 늘어납니다.

즉:

> **가능은 하지만, 이 문제에서는 의미 없이 어렵게 만드는 선택**

면접에서도:

* `l < r` 쓰는 풀이가 **정석**
* 설명도 훨씬 깔끔합니다.

---

## 5️⃣ 감각적으로 기억하는 기준 (중요)

이렇게 외워도 됩니다:

### ✅ `l <= r` 를 쓰는 경우

* “값을 **찾는** 문제”
* mid에서 **정답 여부를 직접 확인**
* return이 루프 안에 있음

### ✅ `l < r` 를 쓰는 경우

* “경계를 **수렴**시키는 문제”
* mid는 **판별용**
* return은 루프 **밖에서 한 번**

---

## 6️⃣ 지금 코드에서의 핵심 정리

현재 코드:

```python
while l < r:
    mid = (l + r) // 2
    if nums[mid] > nums[r]:
        l = mid + 1
    else:
        r = mid
return nums[l]
```

이 구조는:

* mid 검사 ❌
* 구간 제거 ⭕
* 하나로 수렴 ⭕
* 마지막에 확정 ⭕

→ **`l < r`가 정확히 맞는 문제 유형**

---

## 한 줄 요약

> **`l <= r`는 “mid를 검사하는 탐색”,
> `l < r`는 “답이 있는 구간을 수렴시키는 탐색”이다.**

지금 이걸 질문했다는 건,
이진 탐색을 **문법이 아니라 개념 단위로 이해하기 시작했다는 신호**입니다.
Day 6은 사실상 이걸로 완전히 끝났다고 봐도 됩니다.

---

아주 좋은 질문입니다.
이건 **이진 탐색에서 가장 자주 헷갈리고, 동시에 가장 중요한 기준**이라서 한 번 정확히 정리해두면 이후 문제가 훨씬 편해집니다.

결론부터 명확히 말하면:

> **`l < r` vs `l <= r`의 차이는
> “이 루프가 값을 *확정*하는 과정인가,
> 아니면 값을 *검사*하는 과정인가”의 차이입니다.**

아래에서 그 기준을 차분히 정리해볼게요.

---

## 1️⃣ 두 형태의 본질적 차이

### `while l <= r:`

👉 **“mid를 실제 후보로 검사한다”**는 의미

* 루프 안에서:

  * `nums[mid] == target` 같은 **직접 비교**
  * 성공하면 **즉시 return**
* `mid`는 매번 “검사 대상”
* 탐색 대상이 **하나의 값(target)**

👉 **Search 문제**에 적합
(예: Binary Search, Rotated Search)

---

### `while l < r:`

👉 **“구간을 점점 좁혀서 답이 하나로 수렴하게 한다”**

* 루프 안에서:

  * 값을 확정하지 않음
  * **어느 쪽에 답이 있는지만 제거**
* 종료 시점:

  * `l == r` → 그 인덱스가 **정답**
* `mid`는 “판별용 분기점”일 뿐

👉 **Minimum / Boundary / Lower Bound 문제**에 적합

---

## 2️⃣ 지금 문제(Find Minimum)에 왜 `l < r`가 맞는가

이 문제의 성격을 한 문장으로 말하면:

> **“값을 찾는 게 아니라, 정답이 있는 구간을 줄이는 문제”**

여기서는:

* `nums[mid] == 정답`인지 **검사하지 않음**
* 오직:

  * “최솟값이 왼쪽에 있는가?”
  * “오른쪽에 있는가?”
    만 판단합니다.

그래서:

* `mid`를 직접 return할 일이 없음
* `mid`는 제거되거나, 포함되거나 둘 중 하나

👉 이런 경우는 **`l < r`가 자연스러운 종료 조건**입니다.

---

## 3️⃣ 왜 `r = mid`이고, `r = mid - 1`이 아닌가

이건 `l < r`와 강하게 연결됩니다.

```python
if nums[mid] > nums[r]:
    l = mid + 1
else:
    r = mid
```

여기서 중요한 사실:

* `nums[mid] <= nums[r]` 인 경우
  → **mid 자체가 최솟값일 수도 있음**

그래서:

* mid를 버리면 ❌
* mid를 포함해야 ⭕

→ `r = mid` 가 되는 것

그리고 이게 가능하려면:

* `mid`를 포함한 상태에서
* 구간이 계속 줄어들어야 함
  → **`l < r` 구조가 필요**

---

## 4️⃣ 그럼 `l <= r`로도 쓸 수 있나?

이론적으로는 가능합니다.
하지만 그 경우에는:

* 종료 조건이 복잡해지고
* mid == l == r 인 상황을 직접 처리해야 하고
* 불필요한 분기/return이 늘어납니다.

즉:

> **가능은 하지만, 이 문제에서는 의미 없이 어렵게 만드는 선택**

면접에서도:

* `l < r` 쓰는 풀이가 **정석**
* 설명도 훨씬 깔끔합니다.

---

## 5️⃣ 감각적으로 기억하는 기준 (중요)

이렇게 외워도 됩니다:

### ✅ `l <= r` 를 쓰는 경우

* “값을 **찾는** 문제”
* mid에서 **정답 여부를 직접 확인**
* return이 루프 안에 있음

### ✅ `l < r` 를 쓰는 경우

* “경계를 **수렴**시키는 문제”
* mid는 **판별용**
* return은 루프 **밖에서 한 번**

---

## 6️⃣ 지금 코드에서의 핵심 정리

현재 코드:

```python
while l < r:
    mid = (l + r) // 2
    if nums[mid] > nums[r]:
        l = mid + 1
    else:
        r = mid
return nums[l]
```

이 구조는:

* mid 검사 ❌
* 구간 제거 ⭕
* 하나로 수렴 ⭕
* 마지막에 확정 ⭕

→ **`l < r`가 정확히 맞는 문제 유형**

---

## 한 줄 요약

> **`l <= r`는 “mid를 검사하는 탐색”,
> `l < r`는 “답이 있는 구간을 수렴시키는 탐색”이다.**

지금 이걸 질문했다는 건,
이진 탐색을 **문법이 아니라 개념 단위로 이해하기 시작했다는 신호**입니다.
Day 6은 사실상 이걸로 완전히 끝났다고 봐도 됩니다.

---

네, **그렇게 “세트로 묶어 이해하는 감각”이 정확합니다.**
지금 정리한 형태는 거의 **이진 탐색 문제들의 정규 분류표**에 가깝습니다.

다만 한 줄만 아주 미세하게 고쳐주면 **완전히 정확한 정리**가 됩니다.

---

## 네가 잡은 세트 구조 (거의 완벽)

### 1️⃣ Search target 계열

```python
while l <= r:
    mid = (l + r) // 2
    if nums[l] <= nums[mid]:
        # left side sorted
```

* 목적: **값 존재 여부 / 위치 찾기**
* mid는 **실제 검사 대상**
* return이 루프 안에 있음
* `nums[l] <= nums[mid]`로 **정렬된 쪽 판별**

👉 이건 100% 맞음

---

### 2️⃣ Minimum / Boundary / Lower Bound 계열

여기서 **한 줄만 수정하면** 딱 맞아집니다.

네가 쓴:

```python
while l < r:
    ...
    if nums[r] > nums[mid]:
```

이걸 아래처럼 기억하면 정확합니다:

```python
while l < r:
    mid = (l + r) // 2
    if nums[mid] > nums[r]:
        l = mid + 1
    else:
        r = mid
```

즉 **비교식의 방향은 `nums[mid] > nums[r]`** 입니다.

---

## 왜 이 방향이 중요한가

`nums[mid] > nums[r]` 는 질문이 이겁니다:

> “mid가 아직 **왼쪽(큰 값 덩어리)**에 있나?”

* Yes → 최솟값은 오른쪽에 있음
* No → mid 포함 왼쪽에 있음

그래서:

* `l = mid + 1`
* `r = mid`

이게 바로 **경계 수렴 로직**과 맞물립니다.

---

## 이걸 표로 정리하면 (완성형)

| 문제 유형               | loop 조건  | mid 역할 | 정렬 판별 기준               |
| ------------------- | -------- | ------ | ---------------------- |
| Search target       | `l <= r` | 검사 대상  | `nums[l] <= nums[mid]` |
| Find minimum        | `l < r`  | 판별용    | `nums[mid] > nums[r]`  |
| Lower / Upper Bound | `l < r`  | 판별용    | 값 비교 (`nums[mid] < x`) |

---

## 기억하기 좋은 한 문장

> **“찾는 문제는 `l` 기준으로 정렬을 보고,
> 경계 찾는 문제는 `r` 기준으로 피벗을 본다.”**

이 문장 하나면:

* search
* rotated search
* minimum
* bound
  전부 연결됩니다.

---

## 지금 상태 한 마디로 평가하면

이제는:

* “이 문제는 이진 탐색이다” ❌
* **“이 문제는 search 타입인가, boundary 타입인가?” ⭕**

이 단계에 들어왔습니다.

이게 코테에서 **실수 확률이 급격히 줄어드는 지점**입니다.

다음으로 가면:

* Lower Bound / Upper Bound 한 문제
* Binary Search on Answer

이 세트가 완성됩니다.


"""
# CHatGPT 풀이
def find_min(nums: list[int]) -> int:
    l, r = 0, len(nums) - 1

    while l < r:
        mid = (l + r) // 2
        
        if nums[mid] > nums[r]:
            l = mid + 1
        else:
            r = mid

    return nums[l]
            

if __name__ == "__main__":
    nums = [3,4,5,1,2]
    nums = [11,13,15,17]

    print(find_min(nums))